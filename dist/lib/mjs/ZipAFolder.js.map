{"version":3,"sources":["../../../lib/ZipAFolder.ts"],"sourcesContent":["'use strict';\nimport {WriteStream} from 'fs';\nimport path from 'path';\nimport archiver from 'archiver';\nimport fs from 'fs';\nimport isGlob from 'is-glob';\nimport {glob} from 'glob';\n\nexport enum COMPRESSION_LEVEL {\n    uncompressed = 0,\n    medium = 5,\n    high = 9,\n}\n\n/**\n * Options to pass in to zip a folder\n * compression default is 'high'\n */\nexport type ZipAFolderOptions = {\n    compression?: COMPRESSION_LEVEL;\n    customWriteStream?: WriteStream;\n};\n\nexport class ZipAFolder {\n    /**\n     * Tars a given folder or a glob into a gzipped tar archive.\n     * If no zipAFolderOptions are passed in, the default compression level is high.\n     * @param src can be a string path or a glob\n     * @param tarFilePath path to the zip file\n     * @param zipAFolderOptions\n     */\n    static async tar(\n        src: string,\n        tarFilePath: string | undefined,\n        zipAFolderOptions?: ZipAFolderOptions,\n    ): Promise<void | Error> {\n        const o: ZipAFolderOptions = zipAFolderOptions || {\n            compression: COMPRESSION_LEVEL.high,\n        };\n\n        if (o.compression === COMPRESSION_LEVEL.uncompressed) {\n            await ZipAFolder.compress({src, targetFilePath: tarFilePath, format: 'tar', zipAFolderOptions});\n        } else {\n            await ZipAFolder.compress({\n                src,\n                targetFilePath: tarFilePath,\n                format: 'tar',\n                zipAFolderOptions,\n                archiverOptions: {\n                    gzip: true,\n                    gzipOptions: {\n                        level: o.compression,\n                    },\n                },\n            });\n        }\n    }\n\n    /**\n     * Zips a given folder or a glob into a zip archive.\n     * If no zipAFolderOptions are passed in, the default compression level is high.\n     * @param src can be a string path or a glob\n     * @param zipFilePath path to the zip file\n     * @param zipAFolderOptions\n     */\n    static async zip(\n        src: string,\n        zipFilePath: string | undefined,\n        zipAFolderOptions?: ZipAFolderOptions,\n    ): Promise<void | Error> {\n        const o: ZipAFolderOptions = zipAFolderOptions || {\n            compression: COMPRESSION_LEVEL.high,\n        };\n\n        if (o.compression === COMPRESSION_LEVEL.uncompressed) {\n            await ZipAFolder.compress({\n                src,\n                targetFilePath: zipFilePath,\n                format: 'zip',\n                zipAFolderOptions,\n                archiverOptions: {\n                    store: true,\n                },\n            });\n        } else {\n            await ZipAFolder.compress({\n                src,\n                targetFilePath: zipFilePath,\n                format: 'zip',\n                zipAFolderOptions,\n                archiverOptions: {\n                    zlib: {\n                        level: o.compression,\n                    },\n                },\n            });\n        }\n    }\n\n    private static async compress({\n        src,\n        targetFilePath,\n        format,\n        zipAFolderOptions,\n        archiverOptions,\n    }: {\n        src: string;\n        targetFilePath?: string;\n        format: archiver.Format;\n        zipAFolderOptions?: ZipAFolderOptions;\n        archiverOptions?: archiver.ArchiverOptions;\n    }): Promise<void | Error> {\n        let output: WriteStream;\n        const globList: string[] = [];\n\n        if (!zipAFolderOptions?.customWriteStream && targetFilePath) {\n            const targetBasePath: string = path.dirname(targetFilePath);\n\n            if (targetBasePath === src) {\n                throw new Error('Source and target folder must be different.');\n            }\n            try {\n                if (!isGlob(src)) {\n                    await fs.promises.access(src, fs.constants.R_OK); //eslint-disable-line no-bitwise\n                }\n                await fs.promises.access(targetBasePath, fs.constants.R_OK | fs.constants.W_OK); //eslint-disable-line no-bitwise\n            } catch (e: any) {\n                throw new Error(`Permission error: ${e.message}`);\n            }\n\n            if (isGlob(src)) {\n                for (const globPart of src.split(',')) {\n                    globList.push(...(await glob(globPart.trim())));\n                }\n                if (globList.length === 0) {\n                    throw new Error(`No glob match found for \"${src}\".`);\n                }\n            }\n\n            output = fs.createWriteStream(targetFilePath);\n        } else if (zipAFolderOptions && zipAFolderOptions.customWriteStream) {\n            output = zipAFolderOptions?.customWriteStream;\n        } else {\n            throw new Error('You must either provide a target file path or a custom write stream to write to.');\n        }\n\n        const zipArchive: archiver.Archiver = archiver(format, archiverOptions || {});\n\n        return new Promise(async (resolve, reject) => {\n            output.on('close', resolve);\n            output.on('error', reject);\n\n            zipArchive.pipe(output);\n\n            if (isGlob(src)) {\n                for (const file of globList) {\n                    const content = await fs.promises.readFile(file);\n                    zipArchive.append(content, {\n                        name: file,\n                    });\n                }\n            } else {\n                zipArchive.directory(src, false);\n            }\n            zipArchive.finalize();\n        });\n    }\n}\n\nexport const zip = ZipAFolder.zip;\nexport const tar = ZipAFolder.tar;\n"],"names":["path","archiver","fs","isGlob","glob","COMPRESSION_LEVEL","uncompressed","medium","high","ZipAFolder","tar","src","tarFilePath","zipAFolderOptions","o","compression","compress","targetFilePath","format","archiverOptions","gzip","gzipOptions","level","zip","zipFilePath","store","zlib","output","globList","customWriteStream","targetBasePath","dirname","Error","promises","access","constants","R_OK","W_OK","e","message","globPart","split","push","trim","length","createWriteStream","zipArchive","Promise","resolve","reject","on","pipe","file","content","readFile","append","name","directory","finalize"],"mappings":"AAAA;AAEA,OAAOA,UAAU,OAAO;AACxB,OAAOC,cAAc,WAAW;AAChC,OAAOC,QAAQ,KAAK;AACpB,OAAOC,YAAY,UAAU;AAC7B,SAAQC,IAAI,QAAO,OAAO;WAEnB;UAAKC,iBAAiB;IAAjBA,kBAAAA,kBACRC,kBAAe,KAAfA;IADQD,kBAAAA,kBAERE,YAAS,KAATA;IAFQF,kBAAAA,kBAGRG,UAAO,KAAPA;GAHQH,sBAAAA;AAeZ,OAAO,MAAMI;IACT;;;;;;KAMC,GACD,aAAaC,IACTC,GAAW,EACXC,WAA+B,EAC/BC,iBAAqC,EAChB;QACrB,MAAMC,IAAuBD,qBAAqB;YAC9CE,aAAaV,kBAAkBG,IAAI;QACvC;QAEA,IAAIM,EAAEC,WAAW,KAAKV,kBAAkBC,YAAY,EAAE;YAClD,MAAMG,WAAWO,QAAQ,CAAC;gBAACL;gBAAKM,gBAAgBL;gBAAaM,QAAQ;gBAAOL;YAAiB;QACjG,OAAO;YACH,MAAMJ,WAAWO,QAAQ,CAAC;gBACtBL;gBACAM,gBAAgBL;gBAChBM,QAAQ;gBACRL;gBACAM,iBAAiB;oBACbC,MAAM;oBACNC,aAAa;wBACTC,OAAOR,EAAEC,WAAW;oBACxB;gBACJ;YACJ;QACJ;IACJ;IAEA;;;;;;KAMC,GACD,aAAaQ,IACTZ,GAAW,EACXa,WAA+B,EAC/BX,iBAAqC,EAChB;QACrB,MAAMC,IAAuBD,qBAAqB;YAC9CE,aAAaV,kBAAkBG,IAAI;QACvC;QAEA,IAAIM,EAAEC,WAAW,KAAKV,kBAAkBC,YAAY,EAAE;YAClD,MAAMG,WAAWO,QAAQ,CAAC;gBACtBL;gBACAM,gBAAgBO;gBAChBN,QAAQ;gBACRL;gBACAM,iBAAiB;oBACbM,OAAO;gBACX;YACJ;QACJ,OAAO;YACH,MAAMhB,WAAWO,QAAQ,CAAC;gBACtBL;gBACAM,gBAAgBO;gBAChBN,QAAQ;gBACRL;gBACAM,iBAAiB;oBACbO,MAAM;wBACFJ,OAAOR,EAAEC,WAAW;oBACxB;gBACJ;YACJ;QACJ;IACJ;IAEA,aAAqBC,SAAS,EAC1BL,GAAG,EACHM,cAAc,EACdC,MAAM,EACNL,iBAAiB,EACjBM,eAAe,EAOlB,EAAyB;QACtB,IAAIQ;QACJ,MAAMC,WAAqB,EAAE;QAE7B,IAAI,CAACf,mBAAmBgB,qBAAqBZ,gBAAgB;YACzD,MAAMa,iBAAyB9B,KAAK+B,OAAO,CAACd;YAE5C,IAAIa,mBAAmBnB,KAAK;gBACxB,MAAM,IAAIqB,MAAM;YACpB;YACA,IAAI;gBACA,IAAI,CAAC7B,OAAOQ,MAAM;oBACd,MAAMT,GAAG+B,QAAQ,CAACC,MAAM,CAACvB,KAAKT,GAAGiC,SAAS,CAACC,IAAI,GAAG,gCAAgC;gBACtF;gBACA,MAAMlC,GAAG+B,QAAQ,CAACC,MAAM,CAACJ,gBAAgB5B,GAAGiC,SAAS,CAACC,IAAI,GAAGlC,GAAGiC,SAAS,CAACE,IAAI,GAAG,gCAAgC;YACrH,EAAE,OAAOC,GAAQ;gBACb,MAAM,IAAIN,MAAM,CAAC,kBAAkB,EAAEM,EAAEC,OAAO,CAAC,CAAC;YACpD;YAEA,IAAIpC,OAAOQ,MAAM;gBACb,KAAK,MAAM6B,YAAY7B,IAAI8B,KAAK,CAAC,KAAM;oBACnCb,SAASc,IAAI,IAAK,MAAMtC,KAAKoC,SAASG,IAAI;gBAC9C;gBACA,IAAIf,SAASgB,MAAM,KAAK,GAAG;oBACvB,MAAM,IAAIZ,MAAM,CAAC,yBAAyB,EAAErB,IAAI,EAAE,CAAC;gBACvD;YACJ;YAEAgB,SAASzB,GAAG2C,iBAAiB,CAAC5B;QAClC,OAAO,IAAIJ,qBAAqBA,kBAAkBgB,iBAAiB,EAAE;YACjEF,SAASd,mBAAmBgB;QAChC,OAAO;YACH,MAAM,IAAIG,MAAM;QACpB;QAEA,MAAMc,aAAgC7C,SAASiB,QAAQC,mBAAmB,CAAC;QAE3E,OAAO,IAAI4B,QAAQ,OAAOC,SAASC;YAC/BtB,OAAOuB,EAAE,CAAC,SAASF;YACnBrB,OAAOuB,EAAE,CAAC,SAASD;YAEnBH,WAAWK,IAAI,CAACxB;YAEhB,IAAIxB,OAAOQ,MAAM;gBACb,KAAK,MAAMyC,QAAQxB,SAAU;oBACzB,MAAMyB,UAAU,MAAMnD,GAAG+B,QAAQ,CAACqB,QAAQ,CAACF;oBAC3CN,WAAWS,MAAM,CAACF,SAAS;wBACvBG,MAAMJ;oBACV;gBACJ;YACJ,OAAO;gBACHN,WAAWW,SAAS,CAAC9C,KAAK;YAC9B;YACAmC,WAAWY,QAAQ;QACvB;IACJ;AACJ;AAEA,OAAO,MAAMnC,MAAMd,WAAWc,GAAG,CAAC;AAClC,OAAO,MAAMb,MAAMD,WAAWC,GAAG,CAAC"}