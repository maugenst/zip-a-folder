{"version":3,"sources":["../../lib/ZipAFolder.ts"],"sourcesContent":["'use strict';\nimport {WriteStream} from 'fs';\nimport path from 'path';\nimport archiver from 'archiver';\nimport fs from 'fs';\nimport isGlob from 'is-glob';\nimport {glob} from 'glob';\n\nexport enum COMPRESSION_LEVEL {\n    uncompressed = 0,\n    medium = 5,\n    high = 9,\n}\n\n/**\n * Options to pass in to zip a folder\n * compression default is 'high'\n */\nexport type ZipAFolderOptions = {\n    compression?: COMPRESSION_LEVEL;\n    customWriteStream?: WriteStream;\n};\n\nexport class ZipAFolder {\n    /**\n     * Tars a given folder or a glob into a gzipped tar archive.\n     * If no zipAFolderOptions are passed in, the default compression level is high.\n     * @param src can be a string path or a glob\n     * @param tarFilePath path to the zip file\n     * @param zipAFolderOptions\n     */\n    static async tar(\n        src: string,\n        tarFilePath: string | undefined,\n        zipAFolderOptions?: ZipAFolderOptions,\n    ): Promise<void | Error> {\n        const o: ZipAFolderOptions = zipAFolderOptions || {\n            compression: COMPRESSION_LEVEL.high,\n        };\n\n        if (o.compression === COMPRESSION_LEVEL.uncompressed) {\n            await ZipAFolder.compress({src, targetFilePath: tarFilePath, format: 'tar', zipAFolderOptions});\n        } else {\n            await ZipAFolder.compress({\n                src,\n                targetFilePath: tarFilePath,\n                format: 'tar',\n                zipAFolderOptions,\n                archiverOptions: {\n                    gzip: true,\n                    gzipOptions: {\n                        level: o.compression,\n                    },\n                },\n            });\n        }\n    }\n\n    /**\n     * Zips a given folder or a glob into a zip archive.\n     * If no zipAFolderOptions are passed in, the default compression level is high.\n     * @param src can be a string path or a glob\n     * @param zipFilePath path to the zip file\n     * @param zipAFolderOptions\n     */\n    static async zip(\n        src: string,\n        zipFilePath: string | undefined,\n        zipAFolderOptions?: ZipAFolderOptions,\n    ): Promise<void | Error> {\n        const o: ZipAFolderOptions = zipAFolderOptions || {\n            compression: COMPRESSION_LEVEL.high,\n        };\n\n        if (o.compression === COMPRESSION_LEVEL.uncompressed) {\n            await ZipAFolder.compress({\n                src,\n                targetFilePath: zipFilePath,\n                format: 'zip',\n                zipAFolderOptions,\n                archiverOptions: {\n                    store: true,\n                },\n            });\n        } else {\n            await ZipAFolder.compress({\n                src,\n                targetFilePath: zipFilePath,\n                format: 'zip',\n                zipAFolderOptions,\n                archiverOptions: {\n                    zlib: {\n                        level: o.compression,\n                    },\n                },\n            });\n        }\n    }\n\n    private static async compress({\n        src,\n        targetFilePath,\n        format,\n        zipAFolderOptions,\n        archiverOptions,\n    }: {\n        src: string;\n        targetFilePath?: string;\n        format: archiver.Format;\n        zipAFolderOptions?: ZipAFolderOptions;\n        archiverOptions?: archiver.ArchiverOptions;\n    }): Promise<void | Error> {\n        let output: WriteStream;\n\n        if (!zipAFolderOptions?.customWriteStream && targetFilePath) {\n            const targetBasePath: string = path.dirname(targetFilePath);\n\n            if (targetBasePath === src) {\n                throw new Error('Source and target folder must be different.');\n            }\n            try {\n                if (!isGlob(src)) {\n                    await fs.promises.access(src, fs.constants.R_OK); //eslint-disable-line no-bitwise\n                }\n                await fs.promises.access(targetBasePath, fs.constants.R_OK | fs.constants.W_OK); //eslint-disable-line no-bitwise\n            } catch (e: any) {\n                throw new Error(`Permission error: ${e.message}`);\n            }\n\n            if (isGlob(src)) {\n                const globList: string[] = [];\n                for (const globPart of src.split(',')) {\n                    globList.push(...(await glob(globPart.trim())));\n                }\n                if (globList.length === 0) {\n                    throw new Error(`Glob \"${src}\" does not match any files or folders.`);\n                }\n            }\n\n            output = fs.createWriteStream(targetFilePath);\n        } else if (zipAFolderOptions && zipAFolderOptions.customWriteStream) {\n            output = zipAFolderOptions?.customWriteStream;\n        } else {\n            throw new Error('You must either provide a target file path or a custom write stream to write to.');\n        }\n\n        const zipArchive: archiver.Archiver = archiver(format, archiverOptions || {});\n\n        return new Promise((resolve, reject) => {\n            output.on('close', resolve);\n            output.on('error', reject);\n\n            zipArchive.pipe(output);\n\n            if (isGlob(src)) {\n                for (const globPart of src.split(',')) {\n                    zipArchive.glob(globPart);\n                }\n            } else {\n                zipArchive.directory(src, false);\n            }\n            zipArchive.finalize();\n        });\n    }\n}\n\nexport const zip = ZipAFolder.zip;\nexport const tar = ZipAFolder.tar;\n"],"names":["path","archiver","fs","isGlob","glob","COMPRESSION_LEVEL","uncompressed","medium","high","ZipAFolder","tar","src","tarFilePath","zipAFolderOptions","o","compression","compress","targetFilePath","format","archiverOptions","gzip","gzipOptions","level","zip","zipFilePath","store","zlib","output","customWriteStream","targetBasePath","dirname","Error","promises","access","constants","R_OK","W_OK","e","message","globList","globPart","split","push","trim","length","createWriteStream","zipArchive","Promise","resolve","reject","on","pipe","directory","finalize"],"mappings":"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"}