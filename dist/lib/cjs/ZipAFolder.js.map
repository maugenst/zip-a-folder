{"version":3,"sources":["../../../lib/ZipAFolder.ts"],"sourcesContent":["'use strict';\nimport {WriteStream} from 'fs';\nimport path from 'path';\nimport archiver from 'archiver';\nimport fs from 'fs';\nimport isGlob from 'is-glob';\nimport {glob} from 'glob';\n\nexport enum COMPRESSION_LEVEL {\n    uncompressed = 0,\n    medium = 5,\n    high = 9,\n}\n\n/**\n * Options to pass in to zip a folder\n * compression default is 'high'\n */\nexport type ZipAFolderOptions = {\n    compression?: COMPRESSION_LEVEL;\n    customWriteStream?: WriteStream;\n    destPath?: string;\n};\n\nexport class ZipAFolder {\n    /**\n     * Tars a given folder or a glob into a gzipped tar archive.\n     * If no zipAFolderOptions are passed in, the default compression level is high.\n     * @param src can be a string path or a glob\n     * @param tarFilePath path to the zip file\n     * @param zipAFolderOptions\n     */\n    static async tar(\n        src: string,\n        tarFilePath: string | undefined,\n        zipAFolderOptions?: ZipAFolderOptions,\n    ): Promise<void | Error> {\n        const o: ZipAFolderOptions = zipAFolderOptions || {\n            compression: COMPRESSION_LEVEL.high,\n        };\n\n        if (o.compression === COMPRESSION_LEVEL.uncompressed) {\n            await ZipAFolder.compress({src, targetFilePath: tarFilePath, format: 'tar', zipAFolderOptions});\n        } else {\n            await ZipAFolder.compress({\n                src,\n                targetFilePath: tarFilePath,\n                format: 'tar',\n                zipAFolderOptions,\n                archiverOptions: {\n                    gzip: true,\n                    gzipOptions: {\n                        level: o.compression,\n                    },\n                },\n            });\n        }\n    }\n\n    /**\n     * Zips a given folder or a glob into a zip archive.\n     * If no zipAFolderOptions are passed in, the default compression level is high.\n     * @param src can be a string path or a glob\n     * @param zipFilePath path to the zip file\n     * @param zipAFolderOptions\n     */\n    static async zip(\n        src: string,\n        zipFilePath: string | undefined,\n        zipAFolderOptions?: ZipAFolderOptions,\n    ): Promise<void | Error> {\n        const o: ZipAFolderOptions = zipAFolderOptions || {\n            compression: COMPRESSION_LEVEL.high,\n        };\n\n        if (o.compression === COMPRESSION_LEVEL.uncompressed) {\n            await ZipAFolder.compress({\n                src,\n                targetFilePath: zipFilePath,\n                format: 'zip',\n                zipAFolderOptions,\n                archiverOptions: {\n                    store: true,\n                },\n            });\n        } else {\n            await ZipAFolder.compress({\n                src,\n                targetFilePath: zipFilePath,\n                format: 'zip',\n                zipAFolderOptions,\n                archiverOptions: {\n                    zlib: {\n                        level: o.compression,\n                    },\n                },\n            });\n        }\n    }\n\n    private static async compress({\n        src,\n        targetFilePath,\n        format,\n        zipAFolderOptions,\n        archiverOptions,\n    }: {\n        src: string;\n        targetFilePath?: string;\n        format: archiver.Format;\n        zipAFolderOptions?: ZipAFolderOptions;\n        archiverOptions?: archiver.ArchiverOptions;\n    }): Promise<void | Error> {\n        let output: WriteStream;\n        const globList: string[] = [];\n\n        if (!zipAFolderOptions?.customWriteStream && targetFilePath) {\n            const targetBasePath: string = path.dirname(targetFilePath);\n\n            if (targetBasePath === src) {\n                throw new Error('Source and target folder must be different.');\n            }\n            try {\n                if (!isGlob(src)) {\n                    await fs.promises.access(src, fs.constants.R_OK); //eslint-disable-line no-bitwise\n                }\n                await fs.promises.access(targetBasePath, fs.constants.R_OK | fs.constants.W_OK); //eslint-disable-line no-bitwise\n            } catch (e: any) {\n                throw new Error(`Permission error: ${e.message}`);\n            }\n\n            if (isGlob(src)) {\n                for (const globPart of src.split(',')) {\n                    globList.push(...(await glob(globPart.trim())));\n                }\n                if (globList.length === 0) {\n                    throw new Error(`No glob match found for \"${src}\".`);\n                }\n            }\n\n            output = fs.createWriteStream(targetFilePath);\n        } else if (zipAFolderOptions && zipAFolderOptions.customWriteStream) {\n            output = zipAFolderOptions?.customWriteStream;\n        } else {\n            throw new Error('You must either provide a target file path or a custom write stream to write to.');\n        }\n\n        const zipArchive: archiver.Archiver = archiver(format, archiverOptions || {});\n\n        return new Promise(async (resolve, reject) => {\n            output.on('close', resolve);\n            output.on('error', reject);\n\n            zipArchive.pipe(output);\n\n            if (isGlob(src)) {\n                for (const file of globList) {\n                    const content = await fs.promises.readFile(file);\n                    zipArchive.append(content, {\n                        name: file,\n                    });\n                }\n            } else {\n                zipArchive.directory(src, zipAFolderOptions?.destPath || false);\n            }\n            zipArchive.finalize();\n        });\n    }\n}\n\nexport const zip = ZipAFolder.zip;\nexport const tar = ZipAFolder.tar;\n"],"names":["ZipAFolder","zip","tar","COMPRESSION_LEVEL","uncompressed","medium","high","src","tarFilePath","zipAFolderOptions","o","compression","compress","targetFilePath","format","archiverOptions","gzip","gzipOptions","level","zipFilePath","store","zlib","output","globList","targetBasePath","e","globPart","zipArchive","customWriteStream","path","dirname","Error","isGlob","fs","promises","access","constants","R_OK","W_OK","message","split","push","glob","trim","length","createWriteStream","archiver","Promise","resolve","reject","file","content","on","pipe","readFile","append","name","directory","destPath","finalize"],"mappings":"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"}